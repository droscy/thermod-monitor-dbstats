#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
Thermod monitor that collects statistics on thermod operation.

@author:     Simone Rossetto
@copyright:  2018 Simone Rossetto
@license:    GNU General Public License v3
@contact:    simros85@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import signal
import argparse
import requests
import logging
import time
import sqlite3

from thermod import ThermodStatus
from thermod.common import LogStyleAdapter, LOGGER_BASE_NAME, LOGGER_FMT_MSG, \
    LOGGER_FMT_TIME, LOGGER_FMT_STYLE, LOGGER_FMT_MSG_SYSLOG
from logging.handlers import SysLogHandler
from datetime import datetime

__version__ = '1.0.0b1'
__date__ = '2018-04-04'
__updated__ = '2018-04-06'


# setting up logging system
logger = LogStyleAdapter(logging.getLogger('{}.dbstats'.format(LOGGER_BASE_NAME)))
logger.setLevel(logging.INFO)

# shutdown check and return code
RUNNING = True
MAIN_RETURN_CODE = 0

def shutdown(signum=None, frame=None, exitcode=0):
    global RUNNING, MAIN_RETURN_CODE
    logger.info('shutdown requested')
    RUNNING = False
    MAIN_RETURN_CODE = exitcode

signal.signal(signal.SIGTERM, shutdown)

# return codes on error
RET_CODE_SQL_ERR = 21
RET_CODE_UNKNOWN_ERR_INNER = 73
RET_CODE_UNKNOWN_ERR_OUTER = 75
RET_CODE_UNKNOWN_ERR = 77


# parsing input arguments
parser = argparse.ArgumentParser(description='Thermod database statistics gathering')
parser.add_argument('-v', '--version', action='version', version='%(prog)s {}'.format(__version__))
parser.add_argument('-f', '--dbfile', action='store', default='thermod-stats.db', help='path to database file')
parser.add_argument('-t', '--timelimit', action='store', type=int, default=1095, help='number of days to keep in the database (default 3 years, set to 0 to disable)')
parser.add_argument('-H', '--host', action='store', default='localhost', help='thermod socket hostname')
parser.add_argument('-P', '--port', action='store', type=int, default=4344, help='thermod socket port')
parser.add_argument('-C', '--noclean', action='store_true', help='do not delete invalid records on monitor shutdown')
parser.add_argument('-D', '--debug', action='store_true', help='start monitor in debug mode')
parser.add_argument('-d', '--daemon', action='store_true', help='start monitor in background (log to syslog)')
args = parser.parse_args()

if args.debug:
    logger.setLevel(logging.DEBUG)

if args.daemon:
    syslog = SysLogHandler(address='/dev/log', facility=SysLogHandler.LOG_DAEMON)
    syslog.setFormatter(logging.Formatter(fmt=LOGGER_FMT_MSG_SYSLOG,
                                          style=LOGGER_FMT_STYLE))
    logger.addHandler(syslog)
else:
    console = logging.StreamHandler(sys.stdout)
    console.setFormatter(logging.Formatter(fmt=LOGGER_FMT_MSG,
                                           datefmt=LOGGER_FMT_TIME,
                                           style=LOGGER_FMT_STYLE))
    logger.addHandler(console)


# main
logger.info('Thermod DB-Stats monitor v{} started', __version__)

REQUEST_URI = 'http://{}:{}'.format(args.host, args.port)
LAST_STATUS = None
LAST_SWITCHON_TIME = 0

# init queries
_create_table = '''\
create table if not exists thermod_stats 
(
  hostname text not null,
  switchon_time datetime not null,
  switchon_temp real,
  switchon_status text,
  switchoff_time datetime,
  switchoff_temp real,
  switchoff_status text
)'''

_create_index_on = 'create unique index if not exists idx_switchon on thermod_stats (switchon_time)'

_insert_switchon = 'insert into thermod_stats values (?,?,?,?,NULL,NULL,NULL)'

_update_switchoff = '''\
update thermod_stats
set
  switchoff_time = ?,
  switchoff_temp = ?,
  switchoff_status = ?
where hostname = ?
  and switchon_time = ?'''

_delete_old_records = '''\
delete from thermod_stats
where hostname = ?
  and switchon_time < (strftime('%s','now') - (?*24*60*60))'''

_delete_invalid_records = 'delete from thermod_stats where hostname = ? and switchoff_time is null'

try:
    logger.debug('opening database {}', args.dbfile)
    connection = sqlite3.connect(args.dbfile)
    logger.info('database {} opened for host {}', args.dbfile, args.host)
    
    def rollback():
        connection.rollback()
        logger.info('no record has been inserted or updated')

    try:
        logger.debug('opening database cursor')
        cursor = connection.cursor()
        
        logger.debug('creating table and indexes')
        cursor.execute(_create_table)
        cursor.execute(_create_index_on)
        
        logger.debug('creating network session')
        session = requests.Session()
        
        # first connection
        try:    
            logger.debug('get current status from thermod socket')
            rsp = session.get('{}/status'.format(REQUEST_URI))
            rsp.raise_for_status()  # check error status code
            
            logger.debug('processing response data')
            jrsp = rsp.json()
            LAST_STATUS = ThermodStatus(**jrsp)
            logger.debug('current status: {}', LAST_STATUS)
            
            if not LAST_STATUS.error:
                if LAST_STATUS.heating_status == 1:
                    logger.debug('the heating is currently on, inserting a new record in the database')
                    cursor.execute(_insert_switchon, (args.host,
                                                      LAST_STATUS.timestamp,
                                                      LAST_STATUS.current_temperature,
                                                      LAST_STATUS.status))
                    connection.commit()
                    LAST_SWITCHON_TIME = LAST_STATUS.timestamp
                
                else:
                    logger.debug('the heating is currently off, waiting for the first switch on')
            
            else:
                logger.warning('the status returned from thermod contains an '
                               'error: {} ({})', LAST_STATUS.error,
                                                 LAST_STATUS.explain)
                
                logger.info('no record has been inserted or updated')
                # no need to rollback, no query executed
            
        except ValueError as ve:
            logger.warning('invalid value returned from thermod: {}', ve)
            rollback()
        
        except (requests.ConnectionError, requests.Timeout) as e:
            logger.error('cannot contact thermod socket: {}', e)
            rollback()
        
        except requests.RequestException as re:
            logger.error('cannot get current status from thermod: {}', re)
            rollback()
            
        except sqlite3.Error as sqle:
            logger.error('database error: {}', sqle)
            rollback()
        
        # main loop
        while RUNNING:
            try:
                logger.debug('attaching monitor to thermod')
                rsp = session.get('{}/monitor'.format(REQUEST_URI))
                rsp.raise_for_status()  # check error status code
                
                logger.debug('processing response data')
                jrsp = rsp.json()
                status = ThermodStatus(**jrsp)
                logger.debug('current status: {}', status)
                
                if not status.error:
                    if status.heating_status > LAST_STATUS.heating_status:  # heating just switched on
                        logger.debug('the heating has just been switched ON, inserting '
                                     'a new record in the database')
                        
                        cursor.execute(_insert_switchon, (args.host,
                                                          status.timestamp,
                                                          status.current_temperature,
                                                          status.status))
                        connection.commit()
                        LAST_SWITCHON_TIME = status.timestamp
                    
                    elif status.heating_status < LAST_STATUS.heating_status:  # heating just switched off
                        logger.debug('the heating has just been switched OFF, '
                                     'updating the last switchon record '
                                     '(timestamp: {})', LAST_SWITCHON_TIME)
                        
                        cursor.execute(_update_switchoff, (status.timestamp,
                                                           status.current_temperature,
                                                           status.status,
                                                           # the update key is
                                                           # the hostname and
                                                           # timestamp of the
                                                           # last time the
                                                           # heating has been
                                                           # switched on
                                                           args.host,
                                                           LAST_SWITCHON_TIME))
                        connection.commit()
                        LAST_SWITCHON_TIME = 0
                    
                    else:
                        logger.debug('no status change, nothing to do')
                    
                    logger.debug('saving current status as last status')
                    LAST_STATUS = status
                
                else:
                    logger.warning('the status returned from thermod contains an '
                                   'error: {} ({})', LAST_STATUS.error,
                                                     LAST_STATUS.explain)
                    
                    logger.info('no record has been inserted or updated')
                    # no need to rollback, no query executed
            
            except ValueError as ve:
                logger.warning('invalid value returned from thermod: {}', ve)
                rollback()
            
            except requests.RequestException as re:
                logger.error('cannot get current status from thermod: {}', re)
                rollback()
                
                _sleep_sec = 10
                logger.info('going to sleep for {} seconds', _sleep_sec)
                time.sleep(_sleep_sec)
            
            except sqlite3.Error as sqle:
                logger.error('database error: {}', sqle)
                rollback()
            
            except Exception as e:
                logger.critical('unknown error: {}', e)
                rollback()
                shutdown(exitcode=RET_CODE_UNKNOWN_ERR_INNER)
            
            except KeyboardInterrupt:
                logger.debug('shutdown requested by keyboard interrupt')
                shutdown()
                rollback()
        
        # Removing old records only if timelimit is positive and the monitor
        # is shutting down with no errors.
        if args.timelimit > 0 and MAIN_RETURN_CODE == 0:
            try:
                logger.info('deleting records older than {}',
                            datetime.fromtimestamp(time.time() - args.timelimit*24*60*60).strftime('%c'))
                cursor.execute(_delete_old_records, (args.host, args.timelimit))
                connection.commit()
                
            except sqlite3.Error as sqle:
                logger.warning('cannote delete old records: {}', sqle)
                rollback()
        
        # Removing invalid records only if noclean is not set and the monitor
        # is shutting down with no errors.
        if not args.noclean and MAIN_RETURN_CODE == 0:
            try:
                logger.info('deleting invalid records (records with switchon '
                            'time but no switchoff time)')
                
                cursor.execute(_delete_invalid_records, (args.host, ))
                connection.commit()
                
            except sqlite3.Error as sqle:
                logger.warning('cannote delete old records: {}', sqle)
                rollback()
    
    except sqlite3.Error as sqle:
        logger.critical('cannot create table or indexes in database file: {}', sqle)
        MAIN_RETURN_CODE = RET_CODE_SQL_ERR
    
    except Exception as e:
        logger.critical('unknown error creating table or indexes in database file: {}', e)
        MAIN_RETURN_CODE = RET_CODE_UNKNOWN_ERR_OUTER
    
    finally:
        connection.close()

except sqlite3.Error:
    logger.critical('cannot open database file: {}', sqle)
    MAIN_RETURN_CODE = RET_CODE_SQL_ERR

except Exception as e:
    logger.critical('unknown error opening database file: {}', e)
    MAIN_RETURN_CODE = RET_CODE_UNKNOWN_ERR

except KeyboardInterrupt:
    logger.debug('shutdown requested by keyboard interrupt')

logger.info('closing monitor with return code {}', MAIN_RETURN_CODE)
exit(MAIN_RETURN_CODE)

# vim: syntax=python fileencoding=utf-8
